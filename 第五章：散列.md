# 散列
散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是，那些需要元素间任何排序信息的树的操作将不会得到有效的支持。  

理想的散列表数据结构只不过是包含一些项(item)的具有**固定大小的数组**。通常查找是对项的某个部分进行的，这部分就叫作**关键字(key)**。项可以由一个串和其他数据域组成。  
我们把表的大小记作**TableSize**，并将其理解为散列数据结构的一部分。每个关键字被映射到从 0 到 TableSize - 1 这个范围中的某个数，并被放到适当的单元中。这个映射就叫作散列函数(hash function)，理想情况下它应该计算起来简单，并且应该保证任何两个不同的关键字影射到不同的单元。实际上是不可能的，单元的数目是有限的，而关键字实际上是用不完的。因此我们寻找一个散列函数，该函数要在单元之间均匀地分配关键字。  
剩下的问题就是选择一个冲突函数，决定当两个关键字散列到同一个值的时候（这叫冲突(collision)）应该做什么以及如何确定散列表的大小。  
最好保证表的大小是素数。

解决冲突的方法有几种，其中最简单的两种：分离链接法和开放定址法。  
### 分离链接法
将散列到同一个值的所有元素保留到一个表中，通常是双向链表。  
执行查找时，首先使用散列函数来确定究竟遍历哪个链表，然后在被确定的链表中遍历查找。  
执行插入时，我们检查相应的链表卡看该元素是否已经处在适当的位置，
如果是个新元素，那么它将被插入到链表的前端。  

散列表的**填装因子**(load factor) $\lambda$ 为散列表中的元素个数对该表大小的比。链表的平均长度为 $\lambda$。执行一次查找所需要的工作是计算散列函数值所需要的常数时间加上遍历链表所用的时间。

### 探测散列表
不用链表解决冲突的方法是尝试另外一些单元，直到找出空的单元为止。更常见的是，单元$h_0(x),h_1(x),h_2(x),...$相继被试选，其中 $h_i(x) = (hash(x) + f(i)) mod TableSize$，且f(0) = 0。函数 f 是解决冲突的方法。因为所有的数据都要置入表内，这种方案表要比分离链散列表大。填装因子应该低于 0.5 。这样的表叫作探测散列表。  
1. 线性探测。f 是 i 的线性函数。比如 f(i) = i。存在一次聚集问题。
2. 平方探测。f 是 i 的二次函数。解决一次聚集问题。存在二次聚集问题。
3. 双散列。f(i) = $i*hash_2(x)$。将第二个散列函数应用到x。  

### 再散列
对于平方探测的开放定址散列法，如果散列表填的太满，操作的运行时间将开始消耗过长，且插入操作可能失败。这可能发生在有太多的移动和插入混合的场合。一个解决方法是建立另外一个大约两倍大的表，使用一个相关的新散列函数，扫描整个原始散列表并插入到新表中。  

## 5.6 标准库中的散列表
标准库包括 Set 和 Map 的散列表的实现（对应还有 tree 的实现，可以有序），即 HashSet 类和 HashMap 类。HashSet 中的项或 HashMap 中的关键字必须提供 equals 方法和 hashCode 方法。通常是用分离连接散列实现的。  
如果表现是否可以有序查看并不重要，那么这些类可以使用。  

HashMap 的性能常常优于 TreeMap。  
散列表操作中费时最多的部分就是计算 hashCode 方法，所以在 String 类中的 hashCode 方法包含一个重要的优化：每个 String 对象内部都存储它的 hashCode 值。初始为 0，若被调用一次，值被存储。  


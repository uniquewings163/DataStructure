# 表、栈和队列
1. 介绍抽象数据类型的概念。
2. 阐述如何有效地执行表的操作。
3. 介绍栈 ADT 及其在实现递归方面的应用。
4. 介绍队列 ADT 及其在操作系统和算法设计中的应用。

## 抽象数据类型
抽象数据类型（abstract data type, ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在 ADT 的定义中没有解释这组操作是如何实现的。  

## 表 ADT
我们将处理形如 $A_0,A_1,A_2,...,,A_{N-1}$ 的一般的表。表的大小是 N。大小为 0 的特殊的表成为空表。  
除空表以外的任何表，$A_i$ 后继 $A_{i-1}$ 并称 $A_{i-1}$ 前驱 $A_i$。元素 $A_i$ 在表中的位置为 i+1。  
1. 表的简单数组实现  
查找为常数时间，遍历、插入、删除等为线性时间。不适合对表进行频繁的插入和删除操作。  
2. 简单链表
为了避免插入和删除的线性开销，需要保证表可以**不连续存储**，否则表的每个部分可能都需要整体移动。  
链表由一系列节点组成，这些节点不必在内存中相连。每一个节点均**含有表元素和到包含该元素后继元素的节点的链**。我们称之为 next 链。最后一个单元的 next 链引用 null。  
遍历和查找为常数时间，插入、删除为常数时间。

## Java Collections API 中的表
### Collection 接口
**Collections** API 位于 java.util 包中。集合(**collection**)的概念在 Collection 接口中得到抽象。  
Collection 接口扩展了 Iterable 接口。实现 Iterable 接口的类可以拥有增强的 for 循环。  
### Iterator 接口  
实现 Iterable 接口的集合必须提供一个 iterator 的方法，该方法返回一个实现 Iterator 类型的对象，并将当前位置的概念在对象内部存储下来。每次对 next 的调用都给出集合的下一项。  
**在遍历中对集合进行删除操作应该直接通过 iterator 中的 next 和 remove 方法**，其他方式都是不安全的，包括 for 和增强 for 以及集合的 remove、add 等方法。  
集合类的增强 for 循环将由编译器重写为 iterator.hasNext 和 iterator.next 实现。  

### List 接口、ArrayList 类和 LinkedList 类
List ADT 有两种流行的实现方式。  
ArrayList 类提供了 List ADT 的一种可增长数组的实现。优点是对 get 和 set 的调用花费常数时间，缺点是插入和删除代价昂贵。  
LinkedList 类提供了 List ADT 的双链表实现。插入和删除开销小。缺点是不容易作索引，get、set 调用昂贵。  
List 接口提供 ListIterator 扩展了 List 的 Iterator 的功能。方法 previous 和 hasPrevious 使得对表从后向前的遍历得以完成。add 方法将一个新的项以当前位置放入表中。set 改变迭代器看到的最后一个值，next 或 previous。  

## ArrayList 类的实现
使用内部类实现迭代器，说明了为什么不能通过公共类和嵌套类实现。  
1. 保持基础数组，数组的容量，以及存储在 List 中的当前项数。
2. 提供一种机制改变数组的容量。通过获得一个新数组并将老数组拷贝到新数组中来改变数组的容量，允许虚拟机回收老数组。
3. 提供 get 和 set 的实现。
4. 提供基本的方法，如 size、isEmpty、clear、add、remove 等。
5. 提供一个实现 Iterator 接口的类。

## LinkedList 类的实现
在考虑设计方面，我们将需要提供三个类：
1. MyLinkedList 类本身，包含两端的链、表的大小以及一些方法。
2. Node 类，可能是一个是有的嵌套类。一个节点包含数据以及到前一个节点和下一个节点的链，一些适当的构造方法。
3. LinkedListIterator 类，抽象了位置概念，是一个私有类并实现了接口 Iterator。提供了方法 next、hasNext 和 remove 的实现。

增加标记节点(**头节点和为节点**)的意义在于通过排除许多特殊情况极大地简化了编码。例如删除第一个节点和删除最后一个节点。  

## 栈 ADT
### 栈模型
栈(stack) 是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫作栈的顶(top)。对栈的基本操作有 push(进栈) 和 pop(出栈)，前者相当于插入，后者则是删除最后插入的元素。  
对空栈进行 pop 或 top 一般认为是栈 ADT 中的一个错误。  
栈又叫作 LIFO(后进先出)表。  
### 栈的实现
由于栈是一个表，因此**任何实现表的方法都能实现栈**。ArrayList 和 LinkedList 都支持栈操作。栈的操作是常数时间操作。  
ArrayList 需要考虑的是 push 和 pop 是否平衡，是否需要多次扩容。  
### 栈的应用
1. 平衡符号：  
做一个空栈。读入字符直到文件结尾。如果字符是一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则当栈空时报错，否则将栈元素弹出，如果弹出的符号不是对应的开放符号则报错。在文件结尾如果栈非空则报错。时间是线性的，只需要对输入进行一遍检查。  
2. 后缀表达式：
遇到一个符号则出栈并将两个操作数出栈，运算结果再入栈。  
3. 方法调用：
当调用一个新方法时，主调用历程的所有局部变量需要由系统存储起来，否则被调用的新方法将会重写由主调例程的变量所使用的内存。主调例程的当前位置也必须存储，以便在方法调用结束后知道向哪里跳转。

非递归程序一般比等价的递归程序要快，但速度优势的代价是程序清晰性受到影响。  

### 队列 ADT
队列(queue)也是表，使用队列时在一端进行插入，在另一端进行删除。  
队列的基本操作是入队(enqueue)，在表的末端插入一个元素；和出队(dequeue)，在表的队头删除并返回一个元素。  
对队列而言，任何的表的实现都是合法的。  


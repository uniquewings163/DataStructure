# 树
## 预备知识
对于大量的输入数据，链表的线性访问时间太慢，不宜使用。（ArrayList 呢？）  
本章讨论一种简单的数据结构，其大部分操作运行时间平均为 O(log N)。这种数据结构叫作**二叉查找树**。二叉查找树是两种库集合类 TreeSet 和 TreeMap 实现的基础。  
树(Tree)可以用几种方式定义。定义树的一种自然的方式是递归的方式。一棵树是一些节点的集合。这个集合可以是空集；若不是空集，则树由称作**根**(root)的节点 r 以及 0 个或多个非空的（子）树 $T_1,T_2,...,T_k$ 组成，这些子树中的每一颗的根都被来自根 r 的一条有向的 **边**(edge)所连结。  
每一颗子树的根叫作根 r 的儿子(child)，而 r 是每一颗子树的根的父亲(parent)。  
从递归定义中我们发现，一棵树是 N 个节点和 N - 1 条边的集合，其中的一个节点叫作根。  
证明存在 N - 1 条边：每条边都将某个节点连接到它的父亲，而除去根节点外每个节点都有且仅有一个父节点。  
没有儿子的节点成为**叶子节点**(leaf)。  
具有相同父亲的节点为**兄弟节点**(siblings)。  
从节点 $n_1$ 到 $n_k$ 的**路径**定义为节点 $n_1,n_2,...,n_k$ 的一个序列，使得对于 $1 \le i \lt k$ 节点 $n_i$ 是 $n_{i+1}$ 的父亲。这条路径的**长**是为该路径上的边的条数，即 k - 1。  
对任意节点 $n_i, n_i$ 的**深度** 为从根到 $n_i$ 的唯一的路径的长。根节点的深度为 0。$n_i$ 的**高**是从$n_i$到一片树叶的最长路径的长。因此所有叶子节点的高度都是 0。一棵树的高度等于它的根的高。  
### 树的实现
实现树的一种方法可以是在每一个节点除数据外还要有一些链，使得该节点的每一个儿子都有一个链指向它。然而，由于每个节点的儿子数可以变化并且事先不知道，因此建立到各子节点的直接链接是不可行的，因为这样会浪费太多空间。解决方法，将所有儿子都放在树节点的链表中。  
```java
class TreeNode
{
    Object element;
    TreeNode firstChild;
    TreeNode nextSibling;
}
```
这种结构，一个节点最多有两个链，一个指向下一个兄弟节点，一个指向第一个子节点。  
### 树的遍历及应用
树有很多应用。流行的用法之一是包括 UNIX 和 DOS 在内的许多操作系统的目录结构。  
1. 先序遍历
在先序遍历中，对节点的处理工作是在它的所有子节点被处理之前进行的。目录遍历。  
2. 后序遍历
在后序遍历中，对节点的处理工作是在它的所有子节点被处理之后进行的。区块个数统计。

## 二叉树
**二叉树**(binary tree) 是一棵树，其中每个节点都不能有多于两个的子节点。  
二叉树的一个性质是一颗平均二叉树的深度比节点个数 N 小得多。分析表明，其平均深度为 O($\sqrt{N}$)，而对于特殊类型的二叉树，及二叉查找树，其深度的平均值是 O(log N)。最坏情形深度为 N - 1。  
### 实现
因为一个二叉树节点最多有两个子节点，所以我们可以保存直接链接到它们的链。  
```java
class BinaryNode
{
    Object element;
    BinaryNode left;
    BinaryNode right;
}
```
### 表达式树
叶子节点为操作数，其他节点为操作符。  
中序遍历：左，节点，右  

## 查找树 ADT
二叉树的一个重要的应用是它们在查找中的使用。  
使二叉树成为二叉查找树的性质是，对于树中的每个节点 X，它的左字数中所有项的值小于 X 中的项，而它的右子树中所有项的值大于 X 中的项。  
二叉查找树要求所有的项都能够排序。必须实现 Comparable 接口。  
BinarySearchTree，嵌套类 BinaryNode  
唯一的数据域是对根节点的引用，空树为 null。  
contains：通过递归比较直到找到。  
findMin/findMax：通过递归左节点或右节点，也可以使用循环替代递归。  
insert：像 contains 一样沿着树找到合适的位置，将 X 插入到遍历的路径的最后一个节点上，左或者右。  
remove：如果节点是一个叶子节点可以直接删除。如果节点有一个子节点可以在其父节点调整自己的链以绕过该节点。如果有两个子节点，用其右子树中最小的节点的数据代替该节点的数据并递归地删除那个节点。  

## AVL 树
AVL(Adelson-Velskii && Landis) 树是带有平衡条件的二叉查找树。这个平衡条件必须要容易保持，而且它保证树的深度必须是 O(log N)。最简单的想法是要求左右子树具有相同的高度。另一种平衡条件是要求每个节点都必须有相同高度的左子树和右子树，只有理想平衡树满足这个条件，太严格而难以使用。  
一颗 AVL 树是其每个节点的左子树和右子树的高度最多差 1 的二叉查找树(空树的高度定义为 -1)。每一个节点在其节点结构中保留高度信息。  
AVL 树在插入时需要更新通向根节点路径上哪些节点的所有平衡信息，插入一个节点可能破坏 AVL 树的特性，如果发生这种情况就要在插入完成签恢复平衡的性质，可以通过对树进行简单的修正来做到，我们称其为旋转(rotation)。  
只有那些从插入点到根节点的路径上的节点的平衡可能被改变，因为只有这些节点的子树可能发生变化。沿着路径更新平衡信息，可以发现一个节点的新平衡破坏了 AVL 条件。必须重新平衡的节点叫作 $\alpha$。四种情况：
1. 对$\alpha$的左儿子的左子树进行一次插入。
2. 对$\alpha$的左儿子的右子树进行一次插入。
3. 对$\alpha$的右儿子的左子树进行一次插入。
4. 对$\alpha$的右儿子的右子树进行一次插入。

第一种情况是插入发生在“外边”的情况（即左-左、右-右），该情况通过对树的一次单旋转而完成调整。第二种情况发生在“内部”，需要通过双旋转来处理。  

## 4.6 再探树的遍历
由于二叉查找树中对信息进行的排序，因而按照排序的顺序列出所有的项很简单，中序遍历即可。  
后序遍历：计算节点高度，先计算子节点高度  
先序遍历：计算深度  
层序遍历：所有深度为 d 的节点要在深度为 d + 1 的节点之前处理。层序遍历不实用递归，而是用到队列。  

## 4.7 B 树
如果数据量太大不适合放在内存中，而必须放到磁盘上，此时，大 O 模型不再适用。  
问题在于，大 O 分析假设所有的操作耗时都是相等的。然而，涉及磁盘 I/O 的时候就不合适了。  
二叉查找树一次成功的查找可能需要 1.38 log N 次磁盘访问。  
AVL 树接近 log N 次磁盘范围。  
log 10 000 000 约等于 24  
我们想要把磁盘访问次数减小到一个非常小的常数，比如 3 或 4；典型的 AVL 树接近到最优高度，因此二叉查找树是不可行的。  
解法直觉上看是简单的：如果有更多分支，那么就有更少的高度，树的查找和高度相关。  
一棵完全二叉树高度大约为 $log_2N$，一棵完全 M 叉树的高度大约是 $log_MN$。  
在二叉树中需要一个关键字来决定两个分支取用哪个，而 M 叉树需要 M1 个关键字来决定选取哪个分支。而且要避免最坏情况使得 M 叉树退化到二叉查找树的情况。  
实现这种想法的一种方法是使用 B 树。  
**阶为 M 的 B 树是一棵具有以下特性的树：**
1. 数据项存储在树叶上。
2. 非叶子节点存储直到 ***M - 1*** 个关键字（即非叶子节点包含 M - 1 个用来存储关键字的域）以指示搜索的方向；关键字 i 代表子树 i + 1 中的最小的关键字。
3. 树的根或者是一片树叶，或者其儿子数在 2 和 M 之间。
4. 除根外，所有非树叶节点的儿子数在[M/2] 和 M 之间。
5. 所有的树叶都在相同的深度上并有[L/2] 和 L 之间个数据项。

## 4.8 标准库中的集合与映射
List 容器用于查找效率很低。Collections API 提供了两个容器 Set 和 Map，它们对插入、删除和查找等基本操作提供有效的实现。  
### 4.8.1 关于 Set 接口
Set 接口代表不允许重复元素的 Collection。由接口 SortedSet 给出的一种特殊类型的 Set 保证其中的各项处于有序的状态。  
对于 Set，add 方法如果执行成功则返回 true，否则返回 false，因为被添加的项已经存在。  
SortedSet 的一个实现类是 ***TreeSet***。O(log N)。  
默认情况下，排序假设 TreeSet 中的项实现 Comparable 接口。另一种排序可以通过用 Comparator 实例化 TreeSet 来确定。  
> Set<String> s = new TreeSet<>(new CaseInsensitiveCompare());

### 4.8.2 关于 Map 接口
Map 是一个接口，代表由关键字以及它们的值组成的一些项的集合。关键字必须是唯一的，但是不同的关键字可以影射的一些相同的值。
SortedMap 接口，映射中的关键字保持逻辑上的有序。TreeMap 是 SortedMap 接口的一种实现。  
通过一个 Map 进行迭代要比 Collection 复杂，因为 Map 不提供迭代器，而是提供 3 种方法，将 Map 对象的视图作为 Collection 对象返回。这些视图本身是 Collection，因此它们可以被迭代。  
```java
Set<KeyType> keySet();
Collection<ValueType> values();
Set<Map.Entry<keyType, valueType>> entrySet();
```

### 4.8.3 TreeSet 类和 TreeMap 类的实现
Java 要求 TreeSet 和 TreeMap 支持基本的 add、remove 和 contains 操作以**对数**最坏情形时间完成。因此，基本的实现方法就是平衡二叉查找树。一般来说，不使用 AVL 树，而是经常使用一些自顶向下的红黑树。  
